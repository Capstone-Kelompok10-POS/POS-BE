// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	domain "qbills/models/domain"

	gorm "gorm.io/gorm"

	helpers "qbills/utils/helpers"

	mock "github.com/stretchr/testify/mock"

	web "qbills/models/web"
)

// TransactionService is an autogenerated mock type for the TransactionService type
type TransactionService struct {
	mock.Mock
}

// CalculateDiscount provides a mock function with given fields: id, totalPrice
func (_m *TransactionService) CalculateDiscount(id int, totalPrice float64) (float64, error) {
	ret := _m.Called(id, totalPrice)

	var r0 float64
	var r1 error
	if rf, ok := ret.Get(0).(func(int, float64) (float64, error)); ok {
		return rf(id, totalPrice)
	}
	if rf, ok := ret.Get(0).(func(int, float64) float64); ok {
		r0 = rf(id, totalPrice)
	} else {
		r0 = ret.Get(0).(float64)
	}

	if rf, ok := ret.Get(1).(func(int, float64) error); ok {
		r1 = rf(id, totalPrice)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CalculateTotalPrice provides a mock function with given fields: details
func (_m *TransactionService) CalculateTotalPrice(details []domain.TransactionDetail) (float64, error) {
	ret := _m.Called(details)

	var r0 float64
	var r1 error
	if rf, ok := ret.Get(0).(func([]domain.TransactionDetail) (float64, error)); ok {
		return rf(details)
	}
	if rf, ok := ret.Get(0).(func([]domain.TransactionDetail) float64); ok {
		r0 = rf(details)
	} else {
		r0 = ret.Get(0).(float64)
	}

	if rf, ok := ret.Get(1).(func([]domain.TransactionDetail) error); ok {
		r1 = rf(details)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateInvoice provides a mock function with given fields: paymentMethod, paymentType
func (_m *TransactionService) CreateInvoice(paymentMethod uint, paymentType uint) (string, error) {
	ret := _m.Called(paymentMethod, paymentType)

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(uint, uint) (string, error)); ok {
		return rf(paymentMethod, paymentType)
	}
	if rf, ok := ret.Get(0).(func(uint, uint) string); ok {
		r0 = rf(paymentMethod, paymentType)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(uint, uint) error); ok {
		r1 = rf(paymentMethod, paymentType)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTransaction provides a mock function with given fields: request
func (_m *TransactionService) CreateTransaction(request web.TransactionCreateRequest) (*web.TransactionResponse, error) {
	ret := _m.Called(request)

	var r0 *web.TransactionResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(web.TransactionCreateRequest) (*web.TransactionResponse, error)); ok {
		return rf(request)
	}
	if rf, ok := ret.Get(0).(func(web.TransactionCreateRequest) *web.TransactionResponse); ok {
		r0 = rf(request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*web.TransactionResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(web.TransactionCreateRequest) error); ok {
		r1 = rf(request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindAllTransaction provides a mock function with given fields:
func (_m *TransactionService) FindAllTransaction() ([]domain.Transaction, int, error) {
	ret := _m.Called()

	var r0 []domain.Transaction
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func() ([]domain.Transaction, int, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() []domain.Transaction); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func() int); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func() error); ok {
		r2 = rf()
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// FindByCashierIdTransaction provides a mock function with given fields: cashierId
func (_m *TransactionService) FindByCashierIdTransaction(cashierId int) ([]domain.Transaction, error) {
	ret := _m.Called(cashierId)

	var r0 []domain.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(int) ([]domain.Transaction, error)); ok {
		return rf(cashierId)
	}
	if rf, ok := ret.Get(0).(func(int) []domain.Transaction); ok {
		r0 = rf(cashierId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(int) error); ok {
		r1 = rf(cashierId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindByDaily provides a mock function with given fields:
func (_m *TransactionService) FindByDaily() (*domain.TransactionDailyRevenue, error) {
	ret := _m.Called()

	var r0 *domain.TransactionDailyRevenue
	var r1 error
	if rf, ok := ret.Get(0).(func() (*domain.TransactionDailyRevenue, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() *domain.TransactionDailyRevenue); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.TransactionDailyRevenue)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindById provides a mock function with given fields: id
func (_m *TransactionService) FindById(id int) (*domain.Transaction, error) {
	ret := _m.Called(id)

	var r0 *domain.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(int) (*domain.Transaction, error)); ok {
		return rf(id)
	}
	if rf, ok := ret.Get(0).(func(int) *domain.Transaction); ok {
		r0 = rf(id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(int) error); ok {
		r1 = rf(id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindByInvoice provides a mock function with given fields: invoice
func (_m *TransactionService) FindByInvoice(invoice string) (*domain.Transaction, error) {
	ret := _m.Called(invoice)

	var r0 *domain.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (*domain.Transaction, error)); ok {
		return rf(invoice)
	}
	if rf, ok := ret.Get(0).(func(string) *domain.Transaction); ok {
		r0 = rf(invoice)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(invoice)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindByMembershipIdTransaction provides a mock function with given fields: membershipId
func (_m *TransactionService) FindByMembershipIdTransaction(membershipId int) ([]domain.Transaction, error) {
	ret := _m.Called(membershipId)

	var r0 []domain.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(int) ([]domain.Transaction, error)); ok {
		return rf(membershipId)
	}
	if rf, ok := ret.Get(0).(func(int) []domain.Transaction); ok {
		r0 = rf(membershipId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(int) error); ok {
		r1 = rf(membershipId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindByMonthly provides a mock function with given fields:
func (_m *TransactionService) FindByMonthly() ([]domain.TransactionMonthlyRevenue, error) {
	ret := _m.Called()

	var r0 []domain.TransactionMonthlyRevenue
	var r1 error
	if rf, ok := ret.Get(0).(func() ([]domain.TransactionMonthlyRevenue, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() []domain.TransactionMonthlyRevenue); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.TransactionMonthlyRevenue)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindByStatus provides a mock function with given fields: invoice, status
func (_m *TransactionService) FindByStatus(invoice string, status string) (*domain.Transaction, error) {
	ret := _m.Called(invoice, status)

	var r0 *domain.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string) (*domain.Transaction, error)); ok {
		return rf(invoice, status)
	}
	if rf, ok := ret.Get(0).(func(string, string) *domain.Transaction); ok {
		r0 = rf(invoice, status)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(invoice, status)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindByYearly provides a mock function with given fields:
func (_m *TransactionService) FindByYearly() (*domain.TransactionYearlyRevenue, error) {
	ret := _m.Called()

	var r0 *domain.TransactionYearlyRevenue
	var r1 error
	if rf, ok := ret.Get(0).(func() (*domain.TransactionYearlyRevenue, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() *domain.TransactionYearlyRevenue); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.TransactionYearlyRevenue)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindPaginationTransaction provides a mock function with given fields: orderBy, QueryLimit, QueryPage
func (_m *TransactionService) FindPaginationTransaction(orderBy string, QueryLimit string, QueryPage string) ([]domain.Transaction, *helpers.Pagination, error) {
	ret := _m.Called(orderBy, QueryLimit, QueryPage)

	var r0 []domain.Transaction
	var r1 *helpers.Pagination
	var r2 error
	if rf, ok := ret.Get(0).(func(string, string, string) ([]domain.Transaction, *helpers.Pagination, error)); ok {
		return rf(orderBy, QueryLimit, QueryPage)
	}
	if rf, ok := ret.Get(0).(func(string, string, string) []domain.Transaction); ok {
		r0 = rf(orderBy, QueryLimit, QueryPage)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, string) *helpers.Pagination); ok {
		r1 = rf(orderBy, QueryLimit, QueryPage)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*helpers.Pagination)
		}
	}

	if rf, ok := ret.Get(2).(func(string, string, string) error); ok {
		r2 = rf(orderBy, QueryLimit, QueryPage)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// FindRecentTransaction provides a mock function with given fields:
func (_m *TransactionService) FindRecentTransaction() ([]domain.Transaction, error) {
	ret := _m.Called()

	var r0 []domain.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func() ([]domain.Transaction, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() []domain.Transaction); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPricesAndSubTotal provides a mock function with given fields: details
func (_m *TransactionService) GetPricesAndSubTotal(details []domain.TransactionDetail) (map[uint]float64, map[uint]float64, error) {
	ret := _m.Called(details)

	var r0 map[uint]float64
	var r1 map[uint]float64
	var r2 error
	if rf, ok := ret.Get(0).(func([]domain.TransactionDetail) (map[uint]float64, map[uint]float64, error)); ok {
		return rf(details)
	}
	if rf, ok := ret.Get(0).(func([]domain.TransactionDetail) map[uint]float64); ok {
		r0 = rf(details)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[uint]float64)
		}
	}

	if rf, ok := ret.Get(1).(func([]domain.TransactionDetail) map[uint]float64); ok {
		r1 = rf(details)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(map[uint]float64)
		}
	}

	if rf, ok := ret.Get(2).(func([]domain.TransactionDetail) error); ok {
		r2 = rf(details)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ManualPayment provides a mock function with given fields: invoice
func (_m *TransactionService) ManualPayment(invoice string) (*domain.Transaction, error) {
	ret := _m.Called(invoice)

	var r0 *domain.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (*domain.Transaction, error)); ok {
		return rf(invoice)
	}
	if rf, ok := ret.Get(0).(func(string) *domain.Transaction); ok {
		r0 = rf(invoice)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(invoice)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NotificationPayment provides a mock function with given fields: notificationPayload
func (_m *TransactionService) NotificationPayment(notificationPayload map[string]interface{}) error {
	ret := _m.Called(notificationPayload)

	var r0 error
	if rf, ok := ret.Get(0).(func(map[string]interface{}) error); ok {
		r0 = rf(notificationPayload)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ProductStockDecrese provides a mock function with given fields: tx, details
func (_m *TransactionService) ProductStockDecrese(tx *gorm.DB, details []domain.TransactionDetail) error {
	ret := _m.Called(tx, details)

	var r0 error
	if rf, ok := ret.Get(0).(func(*gorm.DB, []domain.TransactionDetail) error); ok {
		r0 = rf(tx, details)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SubtractionPoint provides a mock function with given fields: tx, pointId, membershipId
func (_m *TransactionService) SubtractionPoint(tx *gorm.DB, pointId uint, membershipId uint) (*domain.Membership, error) {
	ret := _m.Called(tx, pointId, membershipId)

	var r0 *domain.Membership
	var r1 error
	if rf, ok := ret.Get(0).(func(*gorm.DB, uint, uint) (*domain.Membership, error)); ok {
		return rf(tx, pointId, membershipId)
	}
	if rf, ok := ret.Get(0).(func(*gorm.DB, uint, uint) *domain.Membership); ok {
		r0 = rf(tx, pointId, membershipId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.Membership)
		}
	}

	if rf, ok := ret.Get(1).(func(*gorm.DB, uint, uint) error); ok {
		r1 = rf(tx, pointId, membershipId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateMemberPoint provides a mock function with given fields: tx, totalPayment, membershipID, pointId
func (_m *TransactionService) UpdateMemberPoint(tx *gorm.DB, totalPayment float64, membershipID uint, pointId uint) error {
	ret := _m.Called(tx, totalPayment, membershipID, pointId)

	var r0 error
	if rf, ok := ret.Get(0).(func(*gorm.DB, float64, uint, uint) error); ok {
		r0 = rf(tx, totalPayment, membershipID, pointId)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateStockProductAndMembershipPoint provides a mock function with given fields: invoice
func (_m *TransactionService) UpdateStockProductAndMembershipPoint(invoice string) error {
	ret := _m.Called(invoice)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(invoice)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NewTransactionService creates a new instance of TransactionService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewTransactionService(t interface {
	mock.TestingT
	Cleanup(func())
}) *TransactionService {
	mock := &TransactionService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
