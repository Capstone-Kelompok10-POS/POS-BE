// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	domain "qbills/models/domain"

	gorm "gorm.io/gorm"

	helpers "qbills/utils/helpers"

	mock "github.com/stretchr/testify/mock"
)

// TransactionRepository is an autogenerated mock type for the TransactionRepository type
type TransactionRepository struct {
	mock.Mock
}

// BeginTransaction provides a mock function with given fields:
func (_m *TransactionRepository) BeginTransaction() *gorm.DB {
	ret := _m.Called()

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func() *gorm.DB); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// FindAllTransaction provides a mock function with given fields:
func (_m *TransactionRepository) FindAllTransaction() ([]domain.Transaction, int, error) {
	ret := _m.Called()

	var r0 []domain.Transaction
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func() ([]domain.Transaction, int, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() []domain.Transaction); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func() int); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func() error); ok {
		r2 = rf()
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// FindByCashierId provides a mock function with given fields: cashierId
func (_m *TransactionRepository) FindByCashierId(cashierId int) ([]domain.Transaction, error) {
	ret := _m.Called(cashierId)

	var r0 []domain.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(int) ([]domain.Transaction, error)); ok {
		return rf(cashierId)
	}
	if rf, ok := ret.Get(0).(func(int) []domain.Transaction); ok {
		r0 = rf(cashierId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(int) error); ok {
		r1 = rf(cashierId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindById provides a mock function with given fields: transactionID
func (_m *TransactionRepository) FindById(transactionID int) (*domain.Transaction, error) {
	ret := _m.Called(transactionID)

	var r0 *domain.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(int) (*domain.Transaction, error)); ok {
		return rf(transactionID)
	}
	if rf, ok := ret.Get(0).(func(int) *domain.Transaction); ok {
		r0 = rf(transactionID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(int) error); ok {
		r1 = rf(transactionID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindByInvoice provides a mock function with given fields: invoice
func (_m *TransactionRepository) FindByInvoice(invoice string) (*domain.Transaction, error) {
	ret := _m.Called(invoice)

	var r0 *domain.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (*domain.Transaction, error)); ok {
		return rf(invoice)
	}
	if rf, ok := ret.Get(0).(func(string) *domain.Transaction); ok {
		r0 = rf(invoice)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(invoice)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindByMembershipId provides a mock function with given fields: membershipId
func (_m *TransactionRepository) FindByMembershipId(membershipId int) ([]domain.Transaction, error) {
	ret := _m.Called(membershipId)

	var r0 []domain.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(int) ([]domain.Transaction, error)); ok {
		return rf(membershipId)
	}
	if rf, ok := ret.Get(0).(func(int) []domain.Transaction); ok {
		r0 = rf(membershipId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(int) error); ok {
		r1 = rf(membershipId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindByStatus provides a mock function with given fields: invoice, status
func (_m *TransactionRepository) FindByStatus(invoice string, status string) (*domain.Transaction, error) {
	ret := _m.Called(invoice, status)

	var r0 *domain.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string) (*domain.Transaction, error)); ok {
		return rf(invoice, status)
	}
	if rf, ok := ret.Get(0).(func(string, string) *domain.Transaction); ok {
		r0 = rf(invoice, status)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(invoice, status)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindDailyTransaction provides a mock function with given fields: currentDate
func (_m *TransactionRepository) FindDailyTransaction(currentDate string) (*domain.TransactionDailyRevenue, error) {
	ret := _m.Called(currentDate)

	var r0 *domain.TransactionDailyRevenue
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (*domain.TransactionDailyRevenue, error)); ok {
		return rf(currentDate)
	}
	if rf, ok := ret.Get(0).(func(string) *domain.TransactionDailyRevenue); ok {
		r0 = rf(currentDate)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.TransactionDailyRevenue)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(currentDate)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindMonthlyRevenue provides a mock function with given fields: currentYear
func (_m *TransactionRepository) FindMonthlyRevenue(currentYear int) ([]domain.TransactionMonthlyRevenue, error) {
	ret := _m.Called(currentYear)

	var r0 []domain.TransactionMonthlyRevenue
	var r1 error
	if rf, ok := ret.Get(0).(func(int) ([]domain.TransactionMonthlyRevenue, error)); ok {
		return rf(currentYear)
	}
	if rf, ok := ret.Get(0).(func(int) []domain.TransactionMonthlyRevenue); ok {
		r0 = rf(currentYear)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.TransactionMonthlyRevenue)
		}
	}

	if rf, ok := ret.Get(1).(func(int) error); ok {
		r1 = rf(currentYear)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindPaginationTransaction provides a mock function with given fields: orderBy, paginate
func (_m *TransactionRepository) FindPaginationTransaction(orderBy string, paginate helpers.Pagination) ([]domain.Transaction, *helpers.Pagination, error) {
	ret := _m.Called(orderBy, paginate)

	var r0 []domain.Transaction
	var r1 *helpers.Pagination
	var r2 error
	if rf, ok := ret.Get(0).(func(string, helpers.Pagination) ([]domain.Transaction, *helpers.Pagination, error)); ok {
		return rf(orderBy, paginate)
	}
	if rf, ok := ret.Get(0).(func(string, helpers.Pagination) []domain.Transaction); ok {
		r0 = rf(orderBy, paginate)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(string, helpers.Pagination) *helpers.Pagination); ok {
		r1 = rf(orderBy, paginate)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*helpers.Pagination)
		}
	}

	if rf, ok := ret.Get(2).(func(string, helpers.Pagination) error); ok {
		r2 = rf(orderBy, paginate)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// FindRecentTransaction provides a mock function with given fields:
func (_m *TransactionRepository) FindRecentTransaction() ([]domain.Transaction, error) {
	ret := _m.Called()

	var r0 []domain.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func() ([]domain.Transaction, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() []domain.Transaction); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindYearlyRevenue provides a mock function with given fields: currentYear
func (_m *TransactionRepository) FindYearlyRevenue(currentYear int) (*domain.TransactionYearlyRevenue, error) {
	ret := _m.Called(currentYear)

	var r0 *domain.TransactionYearlyRevenue
	var r1 error
	if rf, ok := ret.Get(0).(func(int) (*domain.TransactionYearlyRevenue, error)); ok {
		return rf(currentYear)
	}
	if rf, ok := ret.Get(0).(func(int) *domain.TransactionYearlyRevenue); ok {
		r0 = rf(currentYear)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.TransactionYearlyRevenue)
		}
	}

	if rf, ok := ret.Get(1).(func(int) error); ok {
		r1 = rf(currentYear)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Save provides a mock function with given fields: transaction
func (_m *TransactionRepository) Save(transaction *domain.Transaction) (*domain.Transaction, error) {
	ret := _m.Called(transaction)

	var r0 *domain.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*domain.Transaction) (*domain.Transaction, error)); ok {
		return rf(transaction)
	}
	if rf, ok := ret.Get(0).(func(*domain.Transaction) *domain.Transaction); ok {
		r0 = rf(transaction)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*domain.Transaction) error); ok {
		r1 = rf(transaction)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateStatusTransaction provides a mock function with given fields: id, transaction
func (_m *TransactionRepository) UpdateStatusTransaction(id uint, transaction *domain.Transaction) error {
	ret := _m.Called(id, transaction)

	var r0 error
	if rf, ok := ret.Get(0).(func(uint, *domain.Transaction) error); ok {
		r0 = rf(id, transaction)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateStatusTransactionPayment provides a mock function with given fields: status, transactionResult
func (_m *TransactionRepository) UpdateStatusTransactionPayment(status string, transactionResult *domain.PaymentTransactionStatus) error {
	ret := _m.Called(status, transactionResult)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, *domain.PaymentTransactionStatus) error); ok {
		r0 = rf(status, transactionResult)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NewTransactionRepository creates a new instance of TransactionRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewTransactionRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *TransactionRepository {
	mock := &TransactionRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
